# Cursor Rules for UroPrep Project

## Critical Requirements

### Mandatory Test Coverage for New Code

- **ABSOLUTELY MANDATORY**: When writing ANY new code, test cases MUST be written immediately with 100% coverage
- **NO EXCEPTIONS**: New code without 100% test coverage is NOT allowed and will fail SonarQube quality gates
- **Backend (Jest)**: All new backend code MUST have Jest test files with 100% coverage
  - Controllers, services, middleware, utils - ALL must have tests
  - Test files must be created in `backend/tests/` directory
  - Run `npm run test:coverage` in `backend/` to verify coverage
- **Frontend (Vitest)**: All new frontend code MUST have Vitest test files with 100% coverage
  - Components, pages, hooks, utils - ALL must have tests
  - Test files should be co-located or in `__tests__/` directories
  - Run `npm run test:coverage` in `frontend/` to verify coverage
- **Workflow**: Write code → Write tests → Verify 100% coverage → Commit
- **Never skip test writing** - it will cause SonarQube failures and block deployments

### SonarQube Coverage Requirements

- **MANDATORY**: When any file is changed, new code MUST achieve 100% SonarQube coverage
- All new code paths, branches, and functions MUST be covered by unit tests
- Coverage reports must be generated before committing changes:
  - Backend: Run `npm run test:coverage` in the `backend/` directory
  - Frontend: Run `npm run test:coverage` in the `frontend/` directory
- Coverage reports must be verified to show 100% coverage for all new/modified code
- Use the existing coverage configuration in `sonar-project.properties`
- SonarQube will reject code that doesn't meet 100% coverage requirements

### Code Functionality Preservation

- **MANDATORY**: When fixing SonarQube issues, code functionality MUST NOT be changed
- Only refactor code structure, naming, or add missing tests - DO NOT alter business logic
- If a SonarQube issue requires a functional change, discuss with the team first
- Preserve all existing API contracts, function signatures, and behavior
- When fixing code smells or security issues:
  - Extract functions or variables for clarity (refactoring)
  - Add proper error handling without changing error behavior
  - Improve code readability without changing logic
  - Add missing tests to achieve coverage
  - DO NOT change what the code does, only how it's structured

## Project Structure

### Technology Stack

- **Backend**: Node.js (ES Modules), Express.js, PostgreSQL
- **Frontend**: React 19, Vite, TailwindCSS, Redux Toolkit
- **Testing**: Jest (backend), Vitest (frontend), Playwright (E2E)
- **Code Quality**: SonarQube, ESLint

### Testing Frameworks (MANDATORY)

- **Backend Testing - Jest**:
  - **MUST** be used for all backend unit tests
  - Test files location: `backend/tests/`
  - Coverage command: `cd backend && npm run test:coverage`
  - All controllers, services, middleware, and utils MUST have Jest tests
  - Configuration: `backend/jest.config.js`
- **Frontend Testing - Vitest**:
  - **MUST** be used for all frontend unit tests
  - Test files should be co-located with source files or in `__tests__/` directories
  - Coverage command: `cd frontend && npm run test:coverage`
  - All components, pages, hooks, and utils MUST have Vitest tests
  - Configuration: `frontend/vitest.config.js`
- **E2E Testing - Playwright**:
  - Used for end-to-end integration tests
  - Test files location: `e2e/`
- **IMPORTANT**: Using the wrong testing framework (e.g., Jest for frontend or Vitest for backend) will cause SonarQube coverage issues

### Directory Structure

- `backend/` - Express.js API server
  - `controllers/` - Request handlers
  - `routes/` - API route definitions
  - `services/` - Business logic
  - `middleware/` - Express middleware
  - `utils/` - Utility functions
  - `tests/` - Backend unit tests
- `frontend/` - React application
  - `src/` - Source code
  - `src/components/` - React components
  - `src/pages/` - Page components
- `e2e/` - End-to-end tests (Playwright)

## Code Quality Standards

### General Guidelines

- Follow existing code style and patterns
- Use ES6+ features (async/await, destructuring, arrow functions)
- Write self-documenting code with clear variable and function names
- Add JSDoc comments for complex functions
- Keep functions small and focused (single responsibility)

### Backend Guidelines

- Use Express.js best practices
- Implement proper error handling with try-catch blocks
- Use middleware for cross-cutting concerns (auth, validation, rate limiting)
- Validate all inputs using express-validator or Joi
- Use environment variables for configuration (via secure.env)
- Follow RESTful API conventions

### Frontend Guidelines

- Use functional components with React hooks
- Follow React best practices (proper key usage, memoization when needed)
- Use Redux Toolkit for state management
- Implement proper error boundaries
- Sanitize user inputs using DOMPurify
- Use TailwindCSS for styling

### Testing Requirements

- **MANDATORY**: When writing ANY new code, test cases MUST be written immediately with 100% coverage
- **MANDATORY**: All new code must have corresponding test files before the code is considered complete
- **Backend Testing (Jest)**:
  - All new backend code (controllers, services, middleware, utils) MUST have Jest test files
  - Test files should be in `backend/tests/` directory
  - Use Jest for all backend unit tests
  - Run `npm run test:coverage` in `backend/` to verify 100% coverage
- **Frontend Testing (Vitest)**:
  - All new frontend code (components, pages, utils, hooks) MUST have Vitest test files
  - Test files should be co-located with source files or in `__tests__/` directories
  - Use Vitest for all frontend unit tests
  - Run `npm run test:coverage` in `frontend/` to verify 100% coverage
- Test both success and error cases
- Test all code paths, branches, and edge cases
- Mock external dependencies (database, APIs, external services)
- Use descriptive test names that explain what is being tested
- Maintain or improve existing test coverage
- Run tests before committing: `npm test` in respective directories
- **Never commit code without corresponding test files achieving 100% coverage**

## SonarQube Integration

### Before Committing

1. Run test coverage: `npm run test:coverage` (backend) or `npm run test:coverage` (frontend)
2. Verify 100% coverage for new/modified code
3. Check SonarQube analysis results
4. Fix any SonarQube issues while preserving functionality
5. Re-run tests to ensure nothing broke

### SonarQube Issue Resolution

- **Code Smells**: Refactor without changing behavior
- **Bugs**: Fix the bug, but ensure the fix doesn't change intended functionality
- **Security Issues**: Address vulnerabilities without breaking existing features
- **Coverage Issues**: Add tests to cover missing branches/paths
- **Duplications**: Extract common code into reusable functions/modules

## Security Guidelines

- Never commit secrets or credentials
- Use environment variables for sensitive data
- Sanitize all user inputs
- Implement proper authentication and authorization
- Follow OWASP security best practices
- Use parameterized queries for database operations

## Git Workflow

- Write clear, descriptive commit messages
- Make atomic commits (one logical change per commit)
- Test thoroughly before pushing
- Ensure SonarQube quality gate passes before merging

## When Making Changes

### Mandatory Testing Workflow for New Code

1. **Write the code** (controller, component, service, etc.)
2. **IMMEDIATELY write test cases** using the appropriate framework:
   - Backend code → Jest tests in `backend/tests/`
   - Frontend code → Vitest tests (co-located or in `__tests__/`)
3. **Verify 100% coverage**:
   - Backend: `cd backend && npm run test:coverage`
   - Frontend: `cd frontend && npm run test:coverage`
4. **Ensure all tests pass**: `npm test` in respective directories
5. **Only then commit** the code and tests together

### Checklist Before Committing

- [ ] **MANDATORY**: All new code has corresponding test files (Jest for backend, Vitest for frontend)
- [ ] **MANDATORY**: Test coverage is 100% for all new/modified code
- [ ] All tests pass (`npm test` in backend/ and frontend/)
- [ ] Coverage reports generated and verified (100% coverage confirmed)
- [ ] SonarQube issues resolved without changing functionality
- [ ] Code follows project style guidelines
- [ ] No console.log statements left in code
- [ ] Environment variables properly configured
- [ ] No hardcoded credentials or secrets

### If SonarQube Coverage is Below 100%

1. Identify uncovered lines/branches
2. Write tests to cover them
3. Ensure tests verify the actual behavior
4. Re-run coverage to confirm 100%
5. Do NOT remove code to improve coverage - add tests instead

### If Functionality Must Change

- Document why the change is necessary
- Update all affected tests
- Update API documentation if endpoints change
- Ensure backward compatibility when possible
- Get approval before making breaking changes

## Important Notes

- The project uses ES Modules (`"type": "module"` in package.json)
- Backend uses Jest with experimental VM modules flag
- Frontend uses Vitest for testing
- Coverage reports are in LCOV format for SonarQube integration
- Some files are excluded from coverage (see `sonar-project.properties`)
